{
  "comments": [
    {
      "unresolved": true,
      "key": {
        "uuid": "fbfb478e_a89c4fe9",
        "filename": "src/nfc/tags/rw_t2t_ndef.cc",
        "patchSetId": 3
      },
      "lineNbr": 1800,
      "author": {
        "id": 1296738
      },
      "writtenOn": "2020-11-25T12:15:40Z",
      "side": 1,
      "message": "By backward compatibility you meant with CR11, right ?\nIf so, do we really need to support CR11 backward compatibility ?\n\nIf we need to support , for CR11 backward compatibility,\nDynamic lock area is not blocks aligned case can come for \ncase 1 . 1st block of Dynamic lock area \ncase 2 . last block of Dynamic lock area.\n\ncould you please clarify how case 2 is handled here ?",
      "range": {
        "startLine": 1786,
        "startChar": 0,
        "endLine": 1800,
        "endChar": 11
      },
      "revId": "3a0713a15e129fcce4a0f2ba396c99988e1f6fa7",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "e234420d_b1ffc8cf",
        "filename": "src/nfc/tags/rw_t2t_ndef.cc",
        "patchSetId": 3
      },
      "lineNbr": 1800,
      "author": {
        "id": 1231179
      },
      "writtenOn": "2020-12-01T16:03:27Z",
      "side": 1,
      "message": "Yes, by backward compatibility, I meant CR11.\n\nCase 1: 1st block read in case of DynLock_Area start not block aligned allows not to break legacy.\nCase 2: Adding zero padding in the last block in case of DynLock_Area end not block aligned as requested by CR12 for sure breaks legacy. No need to read the last block.\n\nNevertheless I imagine case 1 is still possible with or without having case 2. So I recommend that we keep reading the first block containing dynamic lock bytes if not aligned to a block boundary to only overwrite lock bytes.",
      "parentUuid": "fbfb478e_a89c4fe9",
      "range": {
        "startLine": 1786,
        "startChar": 0,
        "endLine": 1800,
        "endChar": 11
      },
      "revId": "3a0713a15e129fcce4a0f2ba396c99988e1f6fa7",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "b21c527b_2a90fa45",
        "filename": "src/nfc/tags/rw_t2t_ndef.cc",
        "patchSetId": 3
      },
      "lineNbr": 1800,
      "author": {
        "id": 1296738
      },
      "writtenOn": "2020-12-07T13:25:29Z",
      "side": 1,
      "message": "We see a new T2T API NFA_RwT2tReadDynLockBytes(bool read_dyn_locks) added within \"NFC_Forum_CR12\" topic.\nIn order to maintain full CR11 backward compatibility, this new API can be used to decide DynLock_Area to be read or not.\n\nPlease let us know your views.",
      "parentUuid": "e234420d_b1ffc8cf",
      "range": {
        "startLine": 1786,
        "startChar": 0,
        "endLine": 1800,
        "endChar": 11
      },
      "revId": "3a0713a15e129fcce4a0f2ba396c99988e1f6fa7",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "1c3507cd_e939693b",
        "filename": "src/nfc/tags/rw_t2t_ndef.cc",
        "patchSetId": 3
      },
      "lineNbr": 1800,
      "author": {
        "id": 1795865
      },
      "writtenOn": "2020-12-09T10:13:50Z",
      "side": 1,
      "message": "Yes NFA_RwT2tReadDynLockBytes was defined to keep CR11 backward compatibility.\n\nAfter analysis of the AOSP T2T procedures, it appeared that the DynLock_Area content was read at the end of the NDEF detection to store the lock attribute internal table. This procedure is not compliant with NFC Forum technical specifications (NFC Forum does not define how to handle bytes protected by the DynLock_Area). Setting skip_dyn_lock with the new API before the activation allows not to read or read the area.\n\nCurrent NFC Forum test specifications acceptance criteria do not allow the read even if the tools accept it.\n\nSeems the lock attribute value is only used during the computation of the max NDEF length (only the area between the NDEF TLV T field and the first lock byte is considered as available for TLVs_Area in case the DynLock_Area is already defined) and NOT during the NDEF write procedure.\nWe assumed this allows to detect a problem of size to write at NFA level (in JNI) and not later during the execution of the write procedure (write rejected by the tag for protected blocks?). This also implies the area after the DynLock_Area is not available for NDEF data.\n\nThe code to read the DynLock_Area content and the skip_dyn_lock flag could be removed for TR12.1. It would not block the write procedure as the tag would remain in initialized state in case we attempt to write in a forbidden block (procedure would stop, up to applications to restart the procedure). A new write with the appropriate number of data to copy would still be possible.\n\nDo you share our understanding?",
      "parentUuid": "b21c527b_2a90fa45",
      "range": {
        "startLine": 1786,
        "startChar": 0,
        "endLine": 1800,
        "endChar": 11
      },
      "revId": "3a0713a15e129fcce4a0f2ba396c99988e1f6fa7",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "865307b0_a754cd50",
        "filename": "src/nfc/tags/rw_t2t_ndef.cc",
        "patchSetId": 3
      },
      "lineNbr": 1800,
      "author": {
        "id": 1296738
      },
      "writtenOn": "2020-12-10T13:15:53Z",
      "side": 1,
      "message": "\u003e\u003e Current NFC Forum test specifications acceptance criteria do not allow the read even if the tools accept it.\n\n\u003e\u003e Setting skip_dyn_lock with the new API before the activation allows not to read or read the area.\n\n\u003d\u003d\u003d\u003e We have different view on above points.\n\nIUT \u0026 LT tool implementation shall be aligned with CR12 test \u0026 technical spec, not by tool implementation.\nCR12 says, DynLock_Area read not allowed, if tool allowing it, it is wrong tool implementation \u0026 which shall be corrected by tool side.\n\n\nLet\u0027s relook at CR11 \u0026 CR12 T2T technical \u0026 test spec.\n\n- CR11 Technical spec doesn\u0027t explicitly mention DynLock_Area shall be block aligned or not ? However, CR11 Test Spec doesn\u0027t have any test scenario where T2T memory layout has DynLock_Area NOT block aligned. \n\n- CR12 anyways explicitly mentions DynLock_Area shall be block aligned.\n\n- Also, in my understanding, there are no Tag in the field which have a  DynLock_Area which is not block aligned. \n\nSo, for both CR11 \u0026 CR12 as well as field tag, if we can implement assuming DynLock_Area is block aligned, we shall not have any compatibility issue.\n\nDo you agree with above conclusion ? \nCan we avoid this change of \"reading the first block of the DynLock_Area\" ?",
      "parentUuid": "1c3507cd_e939693b",
      "range": {
        "startLine": 1786,
        "startChar": 0,
        "endLine": 1800,
        "endChar": 11
      },
      "revId": "3a0713a15e129fcce4a0f2ba396c99988e1f6fa7",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "646f6d79_f17a8482",
        "filename": "src/nfc/tags/rw_t2t_ndef.cc",
        "patchSetId": 3
      },
      "lineNbr": 1800,
      "author": {
        "id": 1795865
      },
      "writtenOn": "2020-12-11T17:02:05Z",
      "side": 1,
      "message": "I cannot conclude on your statement that excludes we have no tags in the field with unaligned DynLock_Area areas.\n\nWe are mixing several topics whether the DynLock_Area:\n1)\tCould be read at the end of the NDEF Detection.\nThis is controlled by the skip_dyn_lock flag that can be changed with the NFA_RwT2tReadDynLockBytes prior to any activation.\nDo you have an idea why this was done historically? See analysis in previous comment.\n\n2)\tCould be read at any time.\nNo requirement forbids it. If any, please give me the reference in the Tech Spec.\n\n3)\tShould be assumed block aligned for legacy CR11 tags.\nAs you said, in CR11 nothing was specified for the area alignment. \n\nNow CR12 defines in 4.7 of [T2T 1.1] of 2020-06-12 : “The first byte of the DynLock_Area is required to be the first byte of a Block. When the last byte of the DynLock_Area is not the last byte of a Block, the bytes of this Block that are not part of DynLock_Area are Internal Bytes.”\n\nREQ 4.4.1.5 also says: “The Reader/Writer SHALL set any of the Internal Bytes of a Block that partially belong to the DynLock_Area to 00h or SHALL write the existing values. “\nREQ 4.9.5.5 says: “The Reader/Writer SHALL accept a Lock Control TLV encoding a DynLock_Area that starts at ByteNo 0 of a Block and MAY accept a start different to ByteNo 0 of a Block.“\n\nOur proposal in the code compliant with CR12 is:\n- For the first block including dynamic lock bits: \nIf DynLock_Area block aligned, not read is done.\nIf unaligned, read done prior to the write to avoid overwriting existing values.\n- For blocks only containing dynamic lock bits, no read done.\n- For the last block, if Internal bytes exist, they are written with zeros to comply with CR12. In android-R, these bytes were considered as TLVs_Area bytes. This was corrected.\n\nTherefore if the DynLock_Area is already block aligned as requested by CR12 no read will be done on the overall area + Internal bytes if any.\nIf the area start is unaligned, it could happen with the legacy tags, there will be a read for the first block.\n\nWe believe it is a good compromise.",
      "parentUuid": "865307b0_a754cd50",
      "range": {
        "startLine": 1786,
        "startChar": 0,
        "endLine": 1800,
        "endChar": 11
      },
      "revId": "3a0713a15e129fcce4a0f2ba396c99988e1f6fa7",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "08bfe286_9d330658",
        "filename": "src/nfc/tags/rw_t2t_ndef.cc",
        "patchSetId": 3
      },
      "lineNbr": 1800,
      "author": {
        "id": 1296738
      },
      "writtenOn": "2020-12-14T13:20:53Z",
      "side": 1,
      "message": "Based on assumption - there are legacy tags where DynLock_Area is block Unaligned, this code change is OK.",
      "parentUuid": "646f6d79_f17a8482",
      "range": {
        "startLine": 1786,
        "startChar": 0,
        "endLine": 1800,
        "endChar": 11
      },
      "revId": "3a0713a15e129fcce4a0f2ba396c99988e1f6fa7",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    }
  ]
}